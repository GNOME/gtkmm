/* Copyright(C) 2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or(at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

// This is for including the config header before any code (such as
// the #ifndef GTKMM_DISABLE_DEPRECATED in deprecated classes) is generated:
_CONFIGINCLUDE(gtkmmconfig.h)

#include <vector>
#include <cstdlib> // std::strto*()
#include <gtkmm/widget.h>
#include <gtkmm/treeviewcolumn.h>
#include <gtkmm/treeselection.h>
#include <gtkmm/treemodelcolumn.h>
#include <gtkmm/cellrenderer.h>
#include <gtkmm/scrollable.h>
#include <gtkmm/editable.h>
#include <gtkmm/tooltip.h>

_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/widget_p.h)

namespace Gdk
{
class ContentFormats;
}

namespace Gtk
{

_CC_INCLUDE(gtk/gtk.h)

#ifndef DOXYGEN_SHOULD_SKIP_THIS

class TreeView;

namespace TreeView_Private
{
/* This helper function is not a member of TreeView just for the reason that
 * there are compilers that have problems compiling it otherwise. E.g. in gcc
 * 2.95.3 a compiler bug prevents member functions from refering to specialized
 * member function templates and that's what we do here: In function
 * _connect_auto_store_editable_signal_handler we build a slot from
 * TreeView::_auto_store_on_cellrenderer_*_edited. (The latter must be member
 * functions of TreeView since we connect them to signals and we want the
 * connections to vanish when the TreeView dies, of course.)
 */
  template <class ColumnType>
  void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<ColumnType>& model_column);

  template <class ColumnType> inline
  void _connect_auto_store_numeric_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<ColumnType>& model_column);

  template<class ColumnType> inline
  void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);

  template <class ColumnType> inline
  void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);

  template <class ColumnType> inline
  void _auto_cell_data_func(Gtk::CellRenderer* cell, const Gtk::TreeModel::const_iterator& iter, int model_column, const Glib::ustring& format);

  template <typename T>
  T _convert_from_ustring_to_numeric_type(const Glib::ustring& text);
}

#endif //DOXYGEN_SHOULD_SKIP_THIS


//class TreeViewColumn;
class TreeModel;

/** @defgroup TreeView TreeView Classes
 * These classes are used with the Gtk::TreeView widget.
 */

/** The TreeView widget displays the model (Gtk::TreeModel) data and allows the user to interact with it.
 * The View can show all of the model's columns, or just some, and it can show them in various ways.
 * You must provide the TreeModel in the constructor, or with set_model().
 *
 * Add View columns with append_column(), append_column_editable(), append_column_numeric(),
 * append_column_numeric_editable(), insert_column(), or insert_column_editable().
 *
 * You can manipulate the selection by obtaining the @link Gtk::TreeSelection Gtk::TreeView::Selection@endlink from get_selection().
 *
 * @ingroup Widgets
 * @ingroup Containers
 * @ingroup TreeView
 */
class GTKMM_API TreeView
 : public Widget,
   public Scrollable
{
  _CLASS_GTKOBJECT(TreeView, GtkTreeView, GTK_TREE_VIEW, Gtk::Widget, GtkWidget, , , GTKMM_API)
  _IMPLEMENTS_INTERFACE(Scrollable)
  _IGNORE(gtk_tree_view_get_path_at_pos, gtk_tree_view_get_cursor,
          gtk_tree_view_insert_column_with_data_func, gtk_tree_view_get_drag_dest_row, gtk_tree_view_get_dest_row_at_pos)
public:
  _WRAP_ENUM(DropPosition, GtkTreeViewDropPosition, decl_prefix GTKMM_API)
  _WRAP_ENUM(GridLines, GtkTreeViewGridLines, decl_prefix GTKMM_API)

  /**  A visible column in a Gtk::TreeView widget.
   */
  typedef TreeViewColumn Column;

  /** A selection object for Gtk::TreeView.
   */
  typedef TreeSelection Selection;

  /** Default constructor.
   */
  _CTOR_DEFAULT()

  /**
     Constructor that binds to a TreeModel.
   */
  _WRAP_CTOR(TreeView(const Glib::RefPtr<TreeModel>& model), gtk_tree_view_new_with_model)

  _WRAP_METHOD(Glib::RefPtr<TreeModel> get_model(), gtk_tree_view_get_model, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const TreeModel> get_model() const, gtk_tree_view_get_model, refreturn)
  _WRAP_METHOD(void set_model(const Glib::RefPtr<TreeModel>& model), gtk_tree_view_set_model)

  /** Remove the model from the TreeView.
   *
   * @see set_model().
   *
   * @newin{2,8}
   */
  void unset_model();

  _WRAP_METHOD(Glib::RefPtr<TreeSelection> get_selection(), gtk_tree_view_get_selection, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const TreeSelection> get_selection() const, gtk_tree_view_get_selection, refreturn, constversion)

  _WRAP_METHOD(bool get_headers_visible() const, gtk_tree_view_get_headers_visible)
  _WRAP_METHOD(void set_headers_visible(bool headers_visible = true), gtk_tree_view_set_headers_visible)
  _WRAP_METHOD(void columns_autosize(), gtk_tree_view_columns_autosize)
  _WRAP_METHOD(bool get_headers_clickable() const, gtk_tree_view_get_headers_clickable)
  _WRAP_METHOD(void set_headers_clickable(bool setting = true), gtk_tree_view_set_headers_clickable)

  _WRAP_METHOD(void set_activate_on_single_click(bool single = true), gtk_tree_view_set_activate_on_single_click)
  _WRAP_METHOD(bool get_activate_on_single_click() const, gtk_tree_view_get_activate_on_single_click)

  _WRAP_METHOD(int append_column(TreeViewColumn& column), gtk_tree_view_append_column)

  /** Appends a View column with the appropriate CellRenderer for the Model column.
   *
   * The CellRenderer can only be created automatically for some basic
   * column types, such as Glib::ustring, int, double, bool, and Gdk::Pixbuf.
   * If the type is not supported then the following warning will be shown:
   * GLib-GObject-WARNING **: unable to set property `text' of type
   * `gchararray' from value of type `glibmm__CustomBoxed_t'.
   *
   * If the default formatting is not sufficient, or the numeric type is
   * not supported, then you could use append_column_numeric(). Or you
   * could create the TreeView::Column and/or CellRenderer
   * manually and use TreeViewColumn::set_cell_data_func() to provide a callback
   * that converts the model value into a string representation with .
   *
   * The returned value is useful, for example, for connecting the column renderer signal to
   * a slot:
   * @code
   *    int Ncolumns = mTreeView.append_column("Column Title", mColumns.mName);
   *    auto renderer =
   *      dynamic_cast<Gtk::CellRendererText*>(mTreeView.get_column_cell_renderer(Ncolumns-1));
   *    renderer->signal_edited().connect(sigc::mem_fun(*this, &MyWindow::on_name_edited));
   * @endcode
   *
   * @param title The text to be used in the title header of this column.
   * @param model_column The column in the TreeModel that will be rendered by this View column.
   * @result The number of columns in the View after appending.
   */
  template <class ColumnType> inline
  int append_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column);

  /** Like append_column(), but only for numeric types, which will be displayed in the specified format.
   * This convenience template uses TreeView::Column::set_cell_data_func(), so the numeric formatting will
   * be deactivated if you specify your own cell_data callback by calling set_cell_data_func() again.
   *
   * @param title The text to be used in the title header of this column.
   * @param model_column The column in the TreeModel that will be rendered by this View column.
   * @param format A printf-style format, such as "%d", used to create a text representation of the number.
   * @result The number of columns in the View after appending.
   */
  template <class ColumnType> inline
  int append_column_numeric(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format);

  //TODO: danielk suggested use of Glib::Value to simplify/improve this.
  /** Appends a View column with the appropriate CellRenderer for the Model
   * column.  The compiler will attempt to instantiate appropriate template
   * code to automatically store user changes in the model.  To intercept the
   * user's change and implement non-default logic, or if the compiler can't
   * instantiate appropriate code for your model type, you could use
   * append_column() and connect a signal handler to the CellRenderer.
   *
   * @see append_column_numeric_editable().
   *
   * @param title The text to be used in the title header of this column.
   * @param model_column The column in the TreeModel that will be rendered by this View column.
   * @result The number of columns in the View after appending.
   */
  template <class ColumnType> inline
  int append_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column);

  /** Like append_column_editable(), but only for numeric types, which will be displayed in the specified format.
   * This convenience template uses TreeView::Column::set_cell_data_func(), so the numeric formatting will
   * be deactivated if you specify your own cell_data callback by calling set_cell_data_func() again.
   *
   * Note that the @a format does not influence the interpretation of the user's input.
   *
   * @param title The text to be used in the title header of this column.
   * @param model_column The column in the TreeModel that will be rendered by this View column.
   * @param format A printf-style format, such as "%d", used to create a text representation of the number.
   * @result The number of columns in the View after appending.
   */
  template <class ColumnType> inline
  int append_column_numeric_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format);


  /// Creates a View column containing the CellRenderer, and appends it.
  int append_column(const Glib::ustring& title, CellRenderer& cell);

  _WRAP_METHOD(int remove_column(TreeViewColumn& column), gtk_tree_view_remove_column)

  /// Removes all View columns.
  void remove_all_columns();

  _WRAP_METHOD(int insert_column(TreeViewColumn& column, int position), gtk_tree_view_insert_column)

  /** Creates a View column containing the CellRenderer, and inserts it.
   *
   * @param title The text to be used in the title header of this column.
   * @param cell The CellRenderer.
   * @param position The position at which the CellRenderer should be inserted.
   * @result The number of columns in the View after inserting.
   */
  int insert_column(const Glib::ustring& title, CellRenderer& cell, int position);

  _IGNORE(gtk_tree_view_insert_column_with_attributes)

  /** Inserts a View column with the appropriate CellRenderer for the Model column.
   *
   * @param title The text to be used in the title header of this column.
   * @param model_column The column in the TreeModel that will be rendered by this View column.
   * @param position The position at which the CellRenderer should be inserted.
   * @result The number of columns in the View after inserting.
   */
  template <class ColumnType> inline
  int insert_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position);

  /** Inserts a View column with the appropriate CellRenderer for the Model
   * column.  The compiler will attempt to instantiate appropriate template
   * code to automatically store user changes in the model.  To intercept the
   * user's change and implement non-default logic, or if the compiler can't
   * instantiate appropriate code for your model type, you should use
   * insert_column() and connect a signal handler to the CellRenderer.
   *
   * @param title The text to be used in the title header of this column.
   * @param model_column The column in the TreeModel that will be rendered by this View column.
   * @param position The position at which the CellRenderer should be inserted.
   * @result The number of columns in the View after inserting.
   */
  template <class ColumnType> inline
  int insert_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position);

  typedef TreeViewColumn::SlotTreeCellData SlotTreeCellData;

  /**
   * Inserts a new column into the TreeView with the given cell
   * renderer and a SlotTreeCellData to set cell renderer attributes
   * (normally using data from the model).
   *
   * @param position Position to insert, -1 for append
   * @param title column title
   * @param cell cell renderer for column
   * @param slot function to set attributes of cell renderer
   * @return number of columns in the TreeView after the insert
   */
  int insert_column_with_data_func(int position, const Glib::ustring& title, CellRenderer& cell, const SlotTreeCellData& slot);

  _WRAP_METHOD(guint get_n_columns() const, gtk_tree_view_get_n_columns)

  _WRAP_METHOD(TreeViewColumn* get_column(int n), gtk_tree_view_get_column)
  _WRAP_METHOD(const TreeViewColumn* get_column(int n) const, gtk_tree_view_get_column, constversion)

  //The column index is of the view, not the model, so we do not need TreeViewColumn* get_column(TreeViewColumn& base_column).

  /** Gets the CellRenderer for that column.
    * You should dynamic_cast<> to the expected derived CellRenderer type.
    * This assumes that the TreeViewColumn contains only one CellRenderer.
    *
    * @param n The position of the view column.
    * @result The CellRenderer.
    */
  CellRenderer* get_column_cell_renderer(int n);

 //TODO: Add TreeViewColumn* get_column_cell_renderer(TreeViewColumn& base_column); and a const one.


  /** Gets the CellRenderer for that column.
    * You should dynamic_cast<> to the expected derived CellRenderer type.
    * This assumes that the TreeViewColumn contains only one CellRenderer.
    *
    * @param n The position of the view column.
    * @result The CellRenderer.
    */
  const CellRenderer* get_column_cell_renderer(int n) const;

#m4 _CONVERSION(`GList*',`std::vector<TreeViewColumn*>',`Glib::ListHandler<TreeViewColumn*>::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector<TreeViewColumn*> get_columns(), gtk_tree_view_get_columns)
#m4 _CONVERSION(`GList*',`std::vector<const TreeViewColumn*>',`Glib::ListHandler<const TreeViewColumn*>::list_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
  _WRAP_METHOD(std::vector<const TreeViewColumn*> get_columns() const, gtk_tree_view_get_columns)

  _WRAP_METHOD(void move_column_after(TreeViewColumn& column, TreeViewColumn& base_column), gtk_tree_view_move_column_after)

  /** This method moves column to the first position in the view.
   *
   * @param column The view column that will be moved
   */
  void move_column_to_start(TreeViewColumn& column);

  _WRAP_METHOD(void set_expander_column(TreeViewColumn& column), gtk_tree_view_set_expander_column)

  /** This method resets the expander arrow to the default - the first visible column.
   * @see set_expander_column().
   */
  void reset_expander_column();

  _WRAP_METHOD(TreeViewColumn* get_expander_column(), gtk_tree_view_get_expander_column)
  _WRAP_METHOD(const TreeViewColumn* get_expander_column() const, gtk_tree_view_get_expander_column, constversion)

  /** For instance,
   * bool on_column_drop(TreeView*, tree_view, TreeViewColumn* column, TreeViewColumn* prev_column, TreeViewColumn* next_column)
   *
   * This function is called on every column pair in turn at the beginning of a column drag to determine where a
   * drop can take place. The arguments passed to the function are: the tree_view, the view Column being dragged,
   * and the two view Columns determining the drop spot. If either of the view Column arguments for the drop spot
   * are 0, then they indicate an edge.
   */
  typedef sigc::slot<bool(TreeView*, TreeViewColumn*,  TreeViewColumn*, TreeViewColumn*)> SlotColumnDrop;

  /** Sets a callback slot for determining where a column may be dropped when dragged.
   * This function is called on every column pair in turn at the beginning of a column drag to determine where a
   * drop can take place. The arguments passed to the function are: the tree_view, the view Column being dragged,
   * and the two view Columns determining the drop spot. If either of the view Column arguments for the drop spot
   * are 0, then they indicate an edge.
   *
   * See unset_column_drag_function().
   *
   * @param slot A callback function to determine which columns are reorderable.
   */
  void set_column_drag_function(const SlotColumnDrop& slot);
  _IGNORE(gtk_tree_view_set_column_drag_function)

  /** See set_column_drag_function(). After this method has been called, the TreeView reverts to the default behavior of
  * allowing all columns to be dropped everywhere.
  */
  void unset_column_drag_function();

  _WRAP_METHOD(void scroll_to_point(int tree_x, int tree_y), gtk_tree_view_scroll_to_point)

  /** Moves the alignments of tree view to the position specified by @a column and @a path.
   * @a row_align determines where the row is placed, and @a col_align determines where
   * column is placed. Both are expected to be between 0.0 and 1.0. 0.0 means left/top
   * alignment, 1.0 means right/bottom alignment, 0.5 means center.
   *
   * This function only works if the model is set, and @a path is a valid row on the model.
   * If the model changes before the tree view is realized, the centered path will be
   * modified to reflect this change.
   *
   * @param path The path of the row to move to.
   * @param column The Gtk::TreeViewColumn to move horizontally to.
   * @param row_align The vertical alignment of the row specified by @a path.
   * @param col_align The horizontal alignment of the column specified by @a column.
   */
  void scroll_to_cell(const TreeModel::Path& path, TreeViewColumn& column, float row_align, float col_align);
  _IGNORE(gtk_tree_view_scroll_to_cell)

  /** Moves the alignments of tree view to the position specified by @a column and @a path.
   * The tree does the minimum amount of work to scroll the cell onto the screen. This means
   * that the cell will be scrolled to the edge closest to it's current position. If the cell
   * is currently visible on the screen, nothing is done.
   *
   * This function only works if the model is set, and @a path is a valid row on the model.
   * If the model changes before the tree_view is realized, the centered path will be modified
   * to reflect this change.
   *
   * @param path The path of the row to move to.
   * @param column The Gtk::TreeViewColumn to move horizontally to.
   */
  void scroll_to_cell(const TreeModel::Path& path, TreeViewColumn& column);

  /** Moves the alignments of tree view to the position specified by @a path.
   * @a row_align determines where the row is placed, and is expected to be between 0.0
   * and 1.0.  0.0 means top alignment, 1.0 means bottom alignment, 0.5 means center.
   *
   * This function only works if the model is set, and @a path is a valid row on the model.
   * If the model changes before the tree view is realized, the centered path will be
   * modified to reflect this change.
   *
   * @param path The path of the row to move to.
   * @param row_align The vertical alignment of the row specified by @a path.
   */
  void scroll_to_row(const TreeModel::Path& path, float row_align);

  /** Moves the alignments of tree view to the position specified by @a path.
   * The tree does the minimum amount of work to scroll the row onto the screen. This means
   * that the row will be scrolled to the edge closest to it's current position. If the row
   * is currently visible on the screen, nothing is done.
   *
   * This function only works if the model is set, and @a path is a valid row on the model.
   * If the model changes before the tree view is realized, the centered path will be
   * modified to reflect this change.
   *
   * @param path The path of the row to move to.
   */
  void scroll_to_row(const TreeModel::Path& path);

  /** Moves the alignments of tree view to the position specified by @a column.
   * @a col_align determines where the column is placed, and is expected to be between 0.0
   * and 1.0.  0.0 means left alignment, 1.0 means right alignment, 0.5 means center.
   *
   * This function only works if the model is set.  If the model changes before the tree
   * view is realized, the centered path will be modified to reflect this change.
   *
   * @param column The Gtk::TreeViewColumn to move horizontally to.
   * @param col_align The horizontal alignment of the column specified by @a column.
   */
  void scroll_to_column(TreeViewColumn& column, float col_align);

  /** Moves the alignments of tree view to the position specified by @a column.
   * The tree does the minimum amount of work to scroll the column onto the screen. This means
   * that the column will be scrolled to the edge closest to it's current position. If the column
   * is currently visible on the screen, nothing is done.
   *
   * This function only works if the model is set.  If the model changes before the
   * tree view is realized, the centered path will be modified to reflect this change.
   *
   * @param column The Gtk::TreeViewColumn to move horizontally to.
   */
  void scroll_to_column(TreeViewColumn& column);

  _WRAP_METHOD(void row_activated(const TreeModel::Path& path,TreeViewColumn& column), gtk_tree_view_row_activated)
  _WRAP_METHOD(void expand_all(), gtk_tree_view_expand_all)
  _WRAP_METHOD(void collapse_all(), gtk_tree_view_collapse_all)
  _WRAP_METHOD(void expand_to_path(const TreeModel::Path& path), gtk_tree_view_expand_to_path)
  _WRAP_METHOD(bool expand_row(const TreeModel::Path& path, bool open_all), gtk_tree_view_expand_row)
  _WRAP_METHOD(bool collapse_row(const TreeModel::Path& path), gtk_tree_view_collapse_row)

  /** For example,
   * void on_map_expanded_rows(TreeView* tree_view, const TreeModel::Path& path);
   */
  typedef sigc::slot<void(TreeView*, const TreeModel::Path&)> SlotMapping;

  /** Calls the callback slot on all expanded rows.
   * @param slot A callback function to be called.
   */
  void map_expanded_rows(const SlotMapping& slot);
  _IGNORE(gtk_tree_view_map_expanded_rows)

  _WRAP_METHOD(bool row_expanded(const TreeModel::Path& path), gtk_tree_view_row_expanded)
  _WRAP_METHOD(void set_reorderable(bool reorderable = true), gtk_tree_view_set_reorderable)
  _WRAP_METHOD(bool get_reorderable() const, gtk_tree_view_get_reorderable)

  //TODO: Add set_cursor(path, ModelColumnBase&, start_editing)?
  _WRAP_METHOD(void set_cursor(const TreeModel::Path& path, TreeViewColumn& focus_column, bool start_editing = false), gtk_tree_view_set_cursor)

  _WRAP_METHOD(void set_cursor(const TreeModel::Path& path, TreeViewColumn& focus_column, CellRenderer& focus_cell, bool start_editing = false), gtk_tree_view_set_cursor_on_cell)


  /** Sets the current keyboard focus to be at path , and selects it.
   * This is useful when you want to focus the user's attention on a particular row.
   * This function is often followed by Gtk::widget::grab_focus(tree_view)
   * in order to give keyboard focus to the widget.
   *
   *  @param path A reference to cursor path.
   */
  void set_cursor(const TreeModel::Path& path);

  /**  Fills in path and focus_column with the current path and focus column.
   *
   *  @param path A reference to be filled with the current cursor path
   *  @param focus_column A reference to be filled with the current focus column
   */
  void get_cursor(TreeModel::Path& path, TreeViewColumn*& focus_column);

/* Layout information */
  /** Finds the path at the point (@a x, @a y), relative to bin_window coordinates.
   *
   * That is, @a x and @a y are relative to an events coordinates. Widget-relative
   * coordinates must be converted using
   * convert_widget_to_bin_window_coords(). It is primarily for
   * things like popup menus. @a path will be filled
   * with the TreeModel::Path at that point. @a column will be filled
   * with the column at that point.  @a cell_x and @a cell_y return the coordinates
   * relative to the cell background (i.e. the background_area passed to
   * Gtk::CellRenderer::render()).  This method is only meaningful if
   * the TreeView is realized.
   *
   * For converting widget coordinates (eg. the ones you get from
   * Widget::property_query_tooltip()), please see
   * convert_widget_to_bin_window_coords().
   *
   * @param x The x position to be identified (relative to bin_window).
   * @param y The y position to be identified (relative to bin_window).
   * @param[out] path A reference to a TreeModel::Path to be filled in
   * @param[out] column A reference to a TreeViewColumn pointer to be filled in
   * @param[out] cell_x A reference where the X coordinate relative to the cell
   *   can be placed
   * @param[out] cell_y A reference where the Y coordinate relative to the cell
   *   can be placed
   * @return true if a row exists at that coordinate.
   *
   * @newin{2,8}
   */
  bool get_path_at_pos(int x, int y, TreeModel::Path& path, TreeViewColumn*& column, int& cell_x, int& cell_y) const;

  /** Finds the path at the point (@a x, @a y), relative to bin_window coordinates.
   *
   * That is, @a x and @a y are relative to an events coordinates. Widget-relative
   * coordinates must be converted using
   * convert_widget_to_bin_window_coords(). It is primarily for
   * things like popup menus. @a path will be filled
   * with the TreeModel::Path at that point.
   * This method is only meaningful if the TreeView is realized.
   *
   * For converting widget coordinates (eg. the ones you get from
   * Widget::property_query_tooltip()), please see
   * convert_widget_to_bin_window_coords().
   *
   * @param x The x position to be identified (relative to bin_window).
   * @param y The y position to be identified (relative to bin_window).
   * @param path A reference to a TreeModel::Path to be filled in
   * @return true if a row exists at that coordinate.
   *
   * newin{2,16}
   */
  bool get_path_at_pos(int x, int y, TreeModel::Path& path) const;

  //We ignore the fact that one of the arguments can be 0 - it does not seem useful.
  _WRAP_METHOD(void get_cell_area(const TreeModel::Path& path, TreeViewColumn& column, Gdk::Rectangle& rect) const, gtk_tree_view_get_cell_area)

  _WRAP_METHOD(void get_background_area(const TreeModel::Path& path, TreeViewColumn& column, Gdk::Rectangle& rect) const, gtk_tree_view_get_background_area)
  //We ignore the fact that one of the arguments can be 0 - it does not seem useful.

  _WRAP_METHOD(void get_visible_rect(Gdk::Rectangle&  visible_rect) const, gtk_tree_view_get_visible_rect)

   bool get_visible_range(TreeModel::Path& start_path, TreeModel::Path& end_path) const;
  _IGNORE(gtk_tree_view_get_visible_range)

  /** Determine whether the point (@a x, @a y) in the tree view is blank, that is no
   * cell content nor an expander arrow is drawn at the location.
   *
   * If so, the location can be considered as the background. You might wish to take
   * special action on clicks on the background, such as clearing a current
   * selection, having a custom context menu or starting rubber banding.
   *
   * The @a x and @a y coordinates that are provided must be relative to bin_window
   * coordinates.  Widget-relative coordinates must be converted using
   * convert_widget_to_bin_window_coords().
   *
   * For converting widget coordinates (eg. the ones you get from
   * Gtk::Widget::signal_query_tooltip()), please see
   * convert_widget_to_bin_window_coords().
   *
   * The @a path, @a column, @a cell_x and @a cell_y arguments will be filled in
   * likewise as for get_path_at_pos(). Please see get_path_at_pos() for more information.
   *
   * @param x The x position to be identified (relative to bin_window).
   * @param y The y position to be identified (relative to bin_window).
   * @param[out] path A reference to a Gtk::TreePath to be filled in.
   * @param[out] column A reference to a Gtk::TreeViewColumn pointer to be filled in.
   * @param[out] cell_x A reference where the X coordinate relative to the
   *             cell can be placed.
   * @param[out] cell_y A reference where the Y coordinate relative to the
   *             cell can be placed.
   * @return <tt>true</tt> if the area at the given coordinates is blank,
   * <tt>false</tt> otherwise.
   */
  bool is_blank_at_pos(int x, int y, TreePath& path, TreeViewColumn*& column, int& cell_x, int& cell_y) const;
  _IGNORE(gtk_tree_view_is_blank_at_pos)

  /** Determine whether the point (@a x, @a y) in the tree view is blank, that is no
   * cell content nor an expander arrow is drawn at the location.
   *
   * If so, the location can be considered as the background. You might wish to take
   * special action on clicks on the background, such as clearing a current
   * selection, having a custom context menu or starting rubber banding.
   *
   * The @a x and @a y coordinates that are provided must be relative to bin_window
   * coordinates.  Widget-relative coordinates must be converted using
   * convert_widget_to_bin_window_coords().
   *
   * For converting widget coordinates (eg. the ones you get from
   * Gtk::Widget::signal_query_tooltip()), please see
   * convert_widget_to_bin_window_coords().
   *
   * @param x The x position to be identified (relative to bin_window).
   * @param y The y position to be identified (relative to bin_window).
   * @return <tt>true</tt> if the area at the given coordinates is blank,
   * <tt>false</tt> otherwise.
   */
  bool is_blank_at_pos(int x, int y) const;


/* Drag-and-Drop support */
  // Gdk::ContentFormats is an immutable object. It can be declared const
  // in input parameters. No one can change it.

  _WRAP_METHOD(void enable_model_drag_source(const Glib::RefPtr<const Gdk::ContentFormats>& formats{.},
    Gdk::ModifierType start_button_mask{.} = static_cast<Gdk::ModifierType>(GDK_MODIFIER_MASK),
    Gdk::DragAction actions{.} = Gdk::DragAction::COPY | Gdk::DragAction::MOVE),
    gtk_tree_view_enable_model_drag_source)

  /** Turns the TreeView into a drag source for automatic DND.
   * Uses the default "GTK_TREE_MODEL_ROW" target, which the TreeView can handle automatically.
   *
   * @param start_button_mask Mask of allowed buttons to start drag.
   * @param actions The bitmask of possible actions for a drag from this widget.
   */
  void enable_model_drag_source(Gdk::ModifierType start_button_mask = static_cast<Gdk::ModifierType>(GDK_MODIFIER_MASK),
                                Gdk::DragAction actions = Gdk::DragAction::COPY | Gdk::DragAction::MOVE);

  _WRAP_METHOD(void enable_model_drag_dest(const Glib::RefPtr<const Gdk::ContentFormats>& formats,
    Gdk::DragAction actions = Gdk::DragAction::COPY | Gdk::DragAction::MOVE),
    gtk_tree_view_enable_model_drag_dest)

  /** Turns the TreeView into a drop destination for automatic DND.  This uses the default
   *  "GTK_TREE_MODEL_ROW" target, which the TreeView can handle automatically.
   *
   * @param actions The bitmask of possible actions for a drag from this widget.
   */
  void enable_model_drag_dest(Gdk::DragAction actions = Gdk::DragAction::COPY | Gdk::DragAction::MOVE);

  /** Undoes the effect of enable_model_drag_source()
   */
  _WRAP_METHOD(void unset_rows_drag_source(), gtk_tree_view_unset_rows_drag_source)

  /** Undoes the effect of enable_model_drag_dest()
   */
  _WRAP_METHOD(void unset_rows_drag_dest(), gtk_tree_view_unset_rows_drag_dest)


  /* These are useful to implement your own custom stuff. */

  /** Sets the row that is highlighted for feedback.
   * See also unset_drag_dest_row().
   *
   * @param path The path of the row to highlight
   * @param pos Specifies whether to drop before, after or into the row
   */
  _WRAP_METHOD(void set_drag_dest_row(const TreeModel::Path& path, DropPosition pos), gtk_tree_view_set_drag_dest_row)

  /** Remove an existing highlight.
   * See set_drag_dest_row().
   *
   * @newin{3,2}
   */
  void unset_drag_dest_row();

  /** Gets information about the row that is highlighted for feedback.
   *
   * @param path Return location for the path of the highlighted row
   * @param pos Return location for the drop position
   */
  void get_drag_dest_row(TreeModel::Path& path, DropPosition& pos) const;

  /** Determines the destination row for a given position.
   *
   * @param drag_x The x position to determine the destination row for
   * @param drag_y The y position to determine the destination row for
   * @param path Return location for the path of the highlighted row
   * @param pos Return location for the drop position
   */
  bool get_dest_row_at_pos(int drag_x, int drag_y, TreeModel::Path& path, DropPosition& pos) const;

  _WRAP_METHOD(Glib::RefPtr<Gdk::Paintable> create_row_drag_icon(const TreeModel::Path& path) const, gtk_tree_view_create_row_drag_icon)

/* Interactive search */
  _WRAP_METHOD(void set_enable_search(bool enable_search = true), gtk_tree_view_set_enable_search)
  _WRAP_METHOD(bool get_enable_search() const, gtk_tree_view_get_enable_search)
  _WRAP_METHOD(int get_search_column() const, gtk_tree_view_get_search_column)
  _WRAP_METHOD(void set_search_column(const TreeModelColumnBase& column), gtk_tree_view_set_search_column)
  _WRAP_METHOD(void set_search_column(int column), gtk_tree_view_set_search_column)

  /// void on_search_equal(const Glib::RefPtr<TreeModel>& model, int column, const Glib::ustring& key, const TreeModel::const_iterator& iter)
  typedef sigc::slot<bool(const Glib::RefPtr<TreeModel>&, int, const Glib::ustring&, const TreeModel::const_iterator&)> SlotSearchEqual;
  //SlotSearchEqual get_search_equal_func();
  _IGNORE(gtk_tree_view_get_search_equal_func)

  /** Sets the compare function for the interactive search capabilities.
   *
   * @param slot The compare function to use during the search
   */
  void set_search_equal_func(const SlotSearchEqual& slot);
  _IGNORE(gtk_tree_view_set_search_equal_func)

  _WRAP_METHOD(Editable* get_search_entry(), gtk_tree_view_get_search_entry)
  _WRAP_METHOD(const Editable* get_search_entry() const, gtk_tree_view_get_search_entry, constversion)
  _WRAP_METHOD(void set_search_entry(Editable& entry), gtk_tree_view_set_search_entry)

  _WRAP_METHOD(void convert_widget_to_tree_coords(int wx, int wy, int& tx, int& ty) const, gtk_tree_view_convert_widget_to_tree_coords)
  _WRAP_METHOD(void convert_tree_to_widget_coords(int tx, int ty, int& wx, int& wy) const, gtk_tree_view_convert_tree_to_widget_coords)
  _WRAP_METHOD(void convert_widget_to_bin_window_coords(int wx, int wy, int& bx, int& by) const, gtk_tree_view_convert_widget_to_bin_window_coords)
  _WRAP_METHOD(void convert_bin_window_to_widget_coords(int bx, int by, int& wx, int& wy) const, gtk_tree_view_convert_bin_window_to_widget_coords)
  _WRAP_METHOD(void convert_tree_to_bin_window_coords(int tx, int ty, int& bx, int& by) const, gtk_tree_view_convert_tree_to_bin_window_coords)
  _WRAP_METHOD(void convert_bin_window_to_tree_coords(int bx, int by, int& tx, int& ty) const, gtk_tree_view_convert_bin_window_to_tree_coords)


  _WRAP_METHOD(void set_fixed_height_mode(bool enable = true), gtk_tree_view_set_fixed_height_mode)
  _WRAP_METHOD(bool get_fixed_height_mode() const, gtk_tree_view_get_fixed_height_mode)
  _WRAP_METHOD(void set_hover_selection(bool hover = true), gtk_tree_view_set_hover_selection)
  _WRAP_METHOD(bool get_hover_selection() const, gtk_tree_view_get_hover_selection)
  _WRAP_METHOD(void set_hover_expand(bool expand = true), gtk_tree_view_set_hover_expand)
  _WRAP_METHOD(bool get_hover_expand() const, gtk_tree_view_get_hover_expand)
  _WRAP_METHOD(void set_rubber_banding(bool enable = true), gtk_tree_view_set_rubber_banding)
  _WRAP_METHOD(bool get_rubber_banding() const, gtk_tree_view_get_rubber_banding)

  _WRAP_METHOD(bool is_rubber_banding_active() const, gtk_tree_view_is_rubber_banding_active)

  /** The slot type for determining whether the row pointed to by the iterator should be rendered as a separator.
   * Return true if the row is a separator.
   * A common way to implement this is to have a boolean column in the model, whose values the slot returns.
   *
   * For instance,
   * bool on_row_separator(const Glib::RefPtr<Gtk::TreeModel>& model, const Gtk::TreeModel::const_iterator& iter);
   */
  typedef sigc::slot<bool(const Glib::RefPtr<TreeModel>&, const TreeModel::const_iterator&)> SlotRowSeparator;

  /** Sets the row separator function, which is used to determine whether a row should be drawn as a separator.
   */
  void set_row_separator_func(const SlotRowSeparator& slot);
  _IGNORE(gtk_tree_view_set_row_separator_func, gtk_tree_view_get_row_separator_func)

  /** Removes the row separator function, so no separators are drawn.
   * See set_row_separator_func().
   *
   * @newin{3,2}
   */
  void unset_row_separator_func();

  _WRAP_METHOD(void set_grid_lines(GridLines grid_lines), gtk_tree_view_set_grid_lines)
  _WRAP_METHOD(GridLines get_grid_lines() const, gtk_tree_view_get_grid_lines)

  _WRAP_METHOD(void set_enable_tree_lines(bool enable = true), gtk_tree_view_set_enable_tree_lines)
  _WRAP_METHOD(bool get_enable_tree_lines() const, gtk_tree_view_get_enable_tree_lines)

  _WRAP_METHOD(void set_show_expanders(bool enabled = true), gtk_tree_view_set_show_expanders)
  _WRAP_METHOD(bool get_show_expanders() const, gtk_tree_view_get_show_expanders)
  _WRAP_METHOD(void set_level_indentation(int indentation), gtk_tree_view_set_level_indentation)
  _WRAP_METHOD(int get_level_indentation() const, gtk_tree_view_get_level_indentation)

  _WRAP_METHOD(void set_tooltip_row(const Glib::RefPtr<Tooltip>& tooltip, const TreePath& path), gtk_tree_view_set_tooltip_row)

  //Note that we use pointers instead of references because any one of the 3 arguments may be NULL, and we don't want that many method overloads:
#m4 _CONVERSION(`const TreeModel::Path*',`GtkTreePath*',`(($3) ? const_cast<GtkTreePath*>(($3)->gobj()) : nullptr)')
  _WRAP_METHOD(void set_tooltip_cell(const Glib::RefPtr<Tooltip>& tooltip, const TreeModel::Path* path, TreeViewColumn* column, CellRenderer* cell), gtk_tree_view_set_tooltip_cell)

  _IGNORE(gtk_tree_view_get_tooltip_context)

  /** This function is supposed to be used in a Gtk::Widget::query-tooltip
   * signal handler for Gtk::TreeView. The x, y and keyboard_tip values
   * which are received in the signal handler, should be passed to this
   * function without modification.
   *
   * The return value indicates whether there is an tree view row at the given
   * coordinates (true) or not (false) for mouse tooltips. For keyboard
   * tooltips the row returned will be the cursor item. When true, then the
   * @a path which has been provided will be set to point to
   * that row and the corresponding model.
   *
   * @param x The x coordinate (relative to widget coordinates)
   * @param y The y coordinate (relative to widget coordinates)
   * @param keyboard_tip Whether this is a keyboard tooltip or not
   * @param path A reference to receive a Gtk::TreePath
   * @return Whether or not the given tooltip context points to a row.
   *
   * @newin{2,12}
   */
  bool get_tooltip_context_path(int x, int y,
                                bool keyboard_tip,
                                TreeModel::Path& path);

  /** This function is supposed to be used in a Gtk::Widget::query-tooltip
   * signal handler for Gtk::TreeView. The x, y and keyboard_tip values
   * which are received in the signal handler, should be passed to this
   * function without modification.
   *
   * The return value indicates whether there is an tree view row at the given
   * coordinates (true) or not (false) for mouse tooltips. For keyboard
   * tooltips the row returned will be the cursor item. When true, then the
   * @a iter which has been provided will be set to point to
   * that row and the corresponding model.
   *
   * @param x The x coordinate (relative to widget coordinates)
   * @param y The y coordinate (relative to widget coordinates)
   * @param keyboard_tip Whether this is a keyboard tooltip or not
   * @param iter A reference to receive a Gtk::TreeModel::iterator
   * @return Whether or not the given tooltip context points to a row.
   *
   * @newin{2,12}
   */
  bool get_tooltip_context_iter(int x, int y,
                                bool keyboard_tip,
                                Gtk::TreeModel::iterator& iter);

  _WRAP_METHOD(void set_tooltip_column(int column), gtk_tree_view_set_tooltip_column)
  _WRAP_METHOD(int get_tooltip_column() const, gtk_tree_view_get_tooltip_column)

#m4begin
dnl // We need this special conversion here since the C++ Gtk::TreeIter carries
dnl // a pointer to the Gtk::TreeModel, whereas the plain GtkTreeIter struct does
dnl // not.  Fortunately we can use the `self' parameter to get our hands on the
dnl // GtkTreeModel*.
_CONVERSION(`GtkTreeIter*',`const TreeModel::iterator&',`TreeModel::iterator(gtk_tree_view_get_model(self), $3)')
#m4end
  // no_default_handler because GtkTreeViewClass is private.
  _WRAP_SIGNAL(void row_activated(const TreeModel::Path& path, TreeViewColumn* column) , "row-activated", no_default_handler)
  _WRAP_SIGNAL(bool test_expand_row(const TreeModel::iterator& iter, const TreeModel::Path& path), "test-expand-row", no_default_handler)
  _WRAP_SIGNAL(bool test_collapse_row(const TreeModel::iterator& iter, const TreeModel::Path& path), "test-collapse-row", no_default_handler)
  _WRAP_SIGNAL(void row_expanded(const TreeModel::iterator& iter, const TreeModel::Path& path), "row-expanded", no_default_handler)
  _WRAP_SIGNAL(void row_collapsed(const TreeModel::iterator& iter, const TreeModel::Path& path), "row-collapsed", no_default_handler)
  _WRAP_SIGNAL(void cursor_changed(), "cursor-changed", no_default_handler)
  _WRAP_SIGNAL(void columns_changed(), "columns-changed", no_default_handler)

  //Don't wrap these. They are keybinding signals, and their API broke for GTK+ 2.2.
  _IGNORE_SIGNAL("move-cursor")
  _IGNORE_SIGNAL("select-all")
  _IGNORE_SIGNAL("unselect-all")
  _IGNORE_SIGNAL("select-cursor-row")
  _IGNORE_SIGNAL("toggle-cursor-row")
  _IGNORE_SIGNAL("expand-collapse-cursor-row")
  _IGNORE_SIGNAL("select-cursor-parent")
  _IGNORE_SIGNAL("start-interactive-search")

  _WRAP_PROPERTY("model", Glib::RefPtr<TreeModel>)
  _WRAP_PROPERTY("headers-visible", bool)
  _WRAP_PROPERTY("headers-clickable", bool)
  _WRAP_PROPERTY("expander-column", TreeViewColumn*)
  _WRAP_PROPERTY("reorderable", bool)
  _WRAP_PROPERTY("enable-search", bool)
  _WRAP_PROPERTY("search-column", int)
  _WRAP_PROPERTY("fixed-height-mode", bool)
  _WRAP_PROPERTY("hover-selection", bool)
  _WRAP_PROPERTY("hover-expand", bool)
  _WRAP_PROPERTY("show-expanders", bool)
  _WRAP_PROPERTY("level-indentation", bool)
  _WRAP_PROPERTY("rubber-banding", bool)
  _WRAP_PROPERTY("enable-grid-lines", bool)
  _WRAP_PROPERTY("enable-tree-lines", bool)
  _WRAP_PROPERTY("tooltip-column", int)
  _WRAP_PROPERTY("activate-on-single-click", bool)

protected:

#ifndef DOXYGEN_SHOULD_SKIP_THIS
  template<class ColumnType> friend
  void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);

  template <class ColumnType> friend
  void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);

  void _auto_store_on_cellrenderer_toggle_edited_with_model(const Glib::ustring& path_string, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);

  template<class ColumnType> friend
  void TreeView_Private::_connect_auto_store_editable_signal_handler(TreeView*, CellRenderer*, const TreeModelColumn<ColumnType>&);

#endif //DOXYGEN_SHOULD_SKIP_THIS
};



template <class ColumnType> inline
int TreeView::append_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column)
{
  // compilation will fail if there is no appropriate TreeViewColumn
  // constructor for this model column type.
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );

  return append_column(*pViewColumn);
}

template <class ColumnType> inline
int TreeView::append_column_numeric(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format)
{
  TreeViewColumn* const pViewColumn = Gtk::manage( new TreeViewColumn(title) );

  //Use a CellRendererText:
  //We don't use TreeView::Column::append_column(model_column) to generate an appropriate CellRenderer,
  //because that uses set_renderer(), which renders the model value using the automatic glib "transformations" (number-string conversions). As well as being unnecessary here, those automatic conversions can't handle all numeric types.
  CellRenderer* pCellRenderer = manage( new CellRendererText() );
  pViewColumn->pack_start(*pCellRenderer);


  //Some compilers don't like us to give the pointer to a template function directly to sigc::ptr_fun():
  typedef void (*type_fptr)(Gtk::CellRenderer* cell, const Gtk::TreeModel::const_iterator& iter, int model_column, const Glib::ustring& format);
  type_fptr fptr = TreeView_Private::_auto_cell_data_func<ColumnType>;

  //Connect a cell_data callback, to show the number's text representation in the specified format:
  //We use sigc::bind<-1> twice here, instead of sigc::bind() once, because some compilers need the extra hint.
  auto slot = sigc::bind<-1>(
    sigc::bind<-1>( sigc::ptr_fun(fptr), format),
    model_column.index()
  );

  pViewColumn->set_cell_data_func(*pCellRenderer, slot);

  return append_column(*pViewColumn);
}

template <class ColumnType> inline
int TreeView::append_column_numeric_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, const Glib::ustring& format)
{
  int cols_count = append_column_numeric(title, model_column, format);

  //connect signal handlers for auto-storing of edited cell data
  CellRenderer *const cell = get_column_cell_renderer(cols_count - 1);
  if(cell)
  {
    TreeView_Private::_connect_auto_store_numeric_editable_signal_handler<ColumnType>(this, cell, model_column);
  }

  return cols_count;
}

template <class ColumnType> inline
int TreeView::append_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column)
{
  //Don't use this in a header, because it gives warnings when disabled: g_assert(model_column.type() != 0);

  // compilation will fail if there is no appropriate TreeViewColumn
  // constructor for this model column type.
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );

  //connect signal handlers for auto-storing of edited cell data
  CellRenderer* pCellRender = pViewColumn->get_first_cell();
  TreeView_Private::_connect_auto_store_editable_signal_handler<ColumnType>(this, pCellRender, model_column);

  return append_column(*pViewColumn);
}

template <class ColumnType> inline
int TreeView::insert_column(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position)
{
  // compilation will fail if there is no appropriate TreeViewColumn
  // constructor for this model column type.
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );

  return insert_column(*pViewColumn, position);
}

template <class ColumnType> inline
int TreeView::insert_column_editable(const Glib::ustring& title, const TreeModelColumn<ColumnType>& model_column, int position)
{
  // compilation will fail if there is no appropriate TreeViewColumn
  // constructor for this model column type.
  TreeViewColumn *const pViewColumn = Gtk::manage( new TreeViewColumn(title, model_column) );

   //connect signal handlers for auto-storing of edited cell data
  CellRenderer* pCellRender = pViewColumn->get_first_cell();
  TreeView_Private::_connect_auto_store_editable_signal_handler(this, pCellRender, model_column);

  return insert_column(*pViewColumn, position);
}


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace TreeView_Private
{

//Template specializations, for different model column types:

// append_column_editable<>() and insert_column_editable<>() call template function
// _connect_auto_store_editable_signal_handler<ColumnType>().
// There are 3 versions of _connect_auto_store_editable_signal_handler<>():
//
// 1. The default version for string data. It connects
//    CellRendererText::signal_edited() to template function
//    _auto_store_on_cellrenderer_text_edited_string<ColumnType>().
//
// 2. A bool specialization. It connects CellRendererToggle::signal_toggled()
//    to function _auto_store_on_cellrenderer_toggle_edited_with_model().
//
// 3. Several identical (except for the type name) specializations for numeric data.
//    They call _connect_auto_store_numeric_editable_signal_handler<ColumnType>(),
//    which connects CellRendererText::signal_edited() to template function
//    _auto_store_on_cellrenderer_text_edited_numerical<ColumnType>().
//
// We need all those specializations with identical implementations, because we
// chose to avoid multiple specializations for the string types by dealing with
// string types in the default implementation.
//
// With these numeric specializations append_column_editable<>() and
// insert_column_editable<>() can be used for the same numeric types as
// append_column<>() and insert_column<>(). Those are fundamental types in the
// GType system, and Glib registers conversion functions from those types to
// gchararray with g_value_register_transform_func().
// 'short' is not one of those types. It can be handled only by
// append_column_numeric<>() and append_column_numeric_editable<>().

//bool specialization:
template<> GTKMM_API
void _connect_auto_store_editable_signal_handler<bool>(Gtk::TreeView* this_p,
  Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<bool>& model_column);

//int specialization:
template<> GTKMM_API
void _connect_auto_store_editable_signal_handler<int>(Gtk::TreeView* this_p,
  Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<int>& model_column);

//unsigned int specialization:
template<> GTKMM_API
void _connect_auto_store_editable_signal_handler<unsigned int>(Gtk::TreeView* this_p,
  Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<unsigned int>& model_column);

//long specialization:
template<> GTKMM_API
void _connect_auto_store_editable_signal_handler<long>(Gtk::TreeView* this_p,
  Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<long>& model_column);

//unsigned long specialization:
template<> GTKMM_API
void _connect_auto_store_editable_signal_handler<unsigned long>(Gtk::TreeView* this_p,
  Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<unsigned long>& model_column);

//float specialization:
template<> GTKMM_API
void _connect_auto_store_editable_signal_handler<float>(Gtk::TreeView* this_p,
  Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<float>& model_column);

//double specialization:
template<> GTKMM_API
void _connect_auto_store_editable_signal_handler<double>(Gtk::TreeView* this_p,
  Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<double>& model_column);

} // namespace TreeView_Private
#endif //DOXYGEN_SHOULD_SKIP_THIS


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace TreeView_Private
{

// Primary template falls back to std::strtod()
template <typename T>
T _convert_from_ustring_to_numeric_type(const Glib::ustring& text)
{
  return std::strtod(text.c_str(), nullptr);
}

// Floating point specializations
template<> GTKMM_API
float _convert_from_ustring_to_numeric_type<float>(const Glib::ustring& text);

template<> GTKMM_API
long double _convert_from_ustring_to_numeric_type<long double>(const Glib::ustring& text);

// Integral specializations
template<> GTKMM_API
short _convert_from_ustring_to_numeric_type<short>(const Glib::ustring& text);

template<> GTKMM_API
unsigned short _convert_from_ustring_to_numeric_type<unsigned short>(const Glib::ustring& text);

template<> GTKMM_API
int _convert_from_ustring_to_numeric_type<int>(const Glib::ustring& text);

template<> GTKMM_API
unsigned int _convert_from_ustring_to_numeric_type<unsigned int>(const Glib::ustring& text);

template<> GTKMM_API
long _convert_from_ustring_to_numeric_type<long>(const Glib::ustring& text);

template<> GTKMM_API
unsigned long _convert_from_ustring_to_numeric_type<unsigned long>(const Glib::ustring& text);

template<> GTKMM_API
long long _convert_from_ustring_to_numeric_type<long long>(const Glib::ustring& text);

template<> GTKMM_API
unsigned long long _convert_from_ustring_to_numeric_type<unsigned long long>(const Glib::ustring& text);


template <class ColumnType> inline
void _connect_auto_store_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer, const Gtk::TreeModelColumn<ColumnType>& model_column)
{
  //Don't use this in a header, because it gives warnings when disabled: g_assert(model_column.type() != 0);

  //The different CellRenderers have different "edited" signals,
  //and numerical values need to convert the text value to a number,
  //so there are specializations for this template.

  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);

  //Set the appropriate property,
  //and connect to the appropriate signal, sending the model_column too,
  if(pCellText)
  {
    pCellText->property_editable() = true;

    //Some compilers (IRIX MipsPro) don't like us to give the pointer to a template function directly to sigc::ptr_fun():
    typedef void (*type_func)(const Glib::ustring&, const Glib::ustring&, int, const Glib::RefPtr<Gtk::TreeModel>&);
    type_func func = &(Gtk::TreeView_Private::_auto_store_on_cellrenderer_text_edited_string<ColumnType>);
    sigc::slot<void(const Glib::ustring&, const Glib::ustring&, int, const Glib::RefPtr<Gtk::TreeModel>&)> theslot  =
      sigc::ptr_fun(func);

    //We use bind<-1> twice here, instead of using bind() once, because some compilers need the extra hint.
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>( theslot, this_p->get_model()),
        model_column.index()
      )
    );
  }
}

template<class ColumnType> inline
void _connect_auto_store_numeric_editable_signal_handler(Gtk::TreeView* this_p, Gtk::CellRenderer* pCellRenderer,  const Gtk::TreeModelColumn<ColumnType>& model_column)
{
  //The different CellRenderers have different "edited" signals,
  //and numerical values need to convert the text value to a number.

  Gtk::CellRendererText* pCellText = dynamic_cast<Gtk::CellRendererText*>(pCellRenderer);
  if(pCellText)
  {
    //Set the appropriate property.
    pCellText->property_editable() = true;

    //Some compilers don't like us to give the pointer to a template function directly to sigc::ptr_fun():
    typedef void (*type_fptr)(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model);
    type_fptr fptr = _auto_store_on_cellrenderer_text_edited_numerical<ColumnType>;

    //Connect to the appropriate signal, sending the model_column too.
    //We use bind<-1> twice here, instead of using bind() once, because some compilers need the extra hint.
    pCellText->signal_edited().connect(
      sigc::bind<-1>(
        sigc::bind<-1>(
          sigc::ptr_fun(fptr),
          this_p->get_model() ),
        model_column.index()
      )
    );
  }
}

template <class ColumnType> inline
void _auto_store_on_cellrenderer_text_edited_string(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model)
{
  Gtk::TreePath path(path_string);

  //Get the row from the path:
  if(model)
  {
    auto iter = model->get_iter(path);
    if(iter)
    {
        //Store the user's new text in the model:
        Gtk::TreeRow row = *iter;
        row.set_value(model_column, (ColumnType)new_text);
    }
  }
}

template <class ColumnType> inline
void _auto_store_on_cellrenderer_text_edited_numerical(const Glib::ustring& path_string, const Glib::ustring& new_text, int model_column, const Glib::RefPtr<Gtk::TreeModel>& model)
{
  //This is used on numerical model columns:

  Gtk::TreePath path(path_string);

  //Get the row from the path:
  if(model)
  {
    auto iter = model->get_iter(path);
    if(iter)
    {
      // Convert the user's new text to a number, and store the number in the model:
      Gtk::TreeRow row = *iter;
      row.set_value(model_column, _convert_from_ustring_to_numeric_type<ColumnType>(new_text));
    }
  }
}

template <class ColumnType> inline
void _auto_cell_data_func(Gtk::CellRenderer* cell, const Gtk::TreeModel::const_iterator& iter, int model_column, const Glib::ustring& format)
{
  Gtk::CellRendererText* pTextRenderer = dynamic_cast<Gtk::CellRendererText*>(cell);
  if(!pTextRenderer)
  {
    g_warning("gtkmm: TextView: append_column_numeric() was used with a non-numeric type.");
  }
  else
  {
    if(iter)
    {
      //Get the value from the model.
      const auto row = *iter;
      ColumnType value = ColumnType();
      row.get_value(model_column, value);

      //Convert it to a string representation:
      char buff[20];
      int used = g_snprintf(buff, sizeof(buff), format.c_str(), value); //value must be a numeric type.
      if(used > 0)
      {
        //Show the text representation in the view:
        pTextRenderer->property_text() = buff;
      }
    }
  }
}

} // namespace TreeView_Private
#endif //DOXYGEN_SHOULD_SKIP_THIS

} // namespace Gtk
